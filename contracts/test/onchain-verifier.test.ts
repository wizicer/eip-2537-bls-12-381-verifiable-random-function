import { expect } from "chai";
import { network } from "hardhat";
import { prove, generateKeyPair } from '../utils/vrf.js';
import { bls12_381 } from '@noble/curves/bls12-381';
import { bytesToHex, hexToBytes } from '@noble/hashes/utils';

const { ethers } = await network.connect();

describe('On-Chain VRF Verifier', () => {
  let verifier: any;

  before(async () => {
    // Deploy the verifier contract
    verifier = await ethers.deployContract("EIP2537VrfStyleVerifier");
  });

  it('should verify VRF proof generated by JavaScript prover', async () => {
    // 1. Generate key pair using JavaScript
    const { sk, pk } = generateKeyPair();
    
    // 2. Prepare input data
    const input = 'test message for on-chain verification';
    const inputBytes = new TextEncoder().encode(input);
    
    // 3. Generate proof using JavaScript prover with deterministic r_1 for testing
    const r_1 = 12345678901234567890n;
    const proof = prove(sk, pk, input, r_1);
    
    console.log('Generated proof:');
    console.log('  c:', proof.c.toString(16));
    console.log('  s_1:', proof.s_1.toString(16));
    console.log('  preout:', bytesToHex(proof.preout));
    
    // 4. Convert proof data to format expected by Solidity verifier
    // The Solidity verifier expects:
    // - pk: 128-byte uncompressed G1 point (x||y)
    // - inBlob: input bytes
    // - c: challenge scalar
    // - s1: response scalar  
    // - preout: 128-byte uncompressed G1 point (x||y)
    
    // Convert public key to uncompressed format (128 bytes)
    // BLS12-381 G1 points need to be converted to 128-byte format (64 bytes x + 64 bytes y)
    const pkBytes = pk.toRawBytes(false); // 96 bytes uncompressed
    const pkUncompressed = new Uint8Array(128);
    // Copy x coordinate (first 48 bytes) to position 16-63 (zero-padded)
    pkUncompressed.set(pkBytes.slice(0, 48), 16);
    // Copy y coordinate (last 48 bytes) to position 80-127 (zero-padded)
    pkUncompressed.set(pkBytes.slice(48, 96), 80);
    
    // Convert preout to uncompressed format (128 bytes)
    const preoutPoint = bls12_381.G1.ProjectivePoint.fromHex(bytesToHex(proof.preout));
    const preoutBytes = preoutPoint.toRawBytes(false); // 96 bytes uncompressed
    const preoutUncompressed = new Uint8Array(128);
    // Copy x coordinate (first 48 bytes) to position 16-63 (zero-padded)
    preoutUncompressed.set(preoutBytes.slice(0, 48), 16);
    // Copy y coordinate (last 48 bytes) to position 80-127 (zero-padded)
    preoutUncompressed.set(preoutBytes.slice(48, 96), 80);
    
    console.log('Converted data:');
    console.log('  pk length:', pkUncompressed.length, 'bytes');
    console.log('  preout length:', preoutUncompressed.length, 'bytes');
    console.log('  pk (uncompressed):', bytesToHex(pkUncompressed));
    console.log('  preout (uncompressed):', bytesToHex(preoutUncompressed));
    console.log('  input bytes:', bytesToHex(inputBytes));
    
    // 5. Call the on-chain verifier
    const result = await verifier.verify(
      pkUncompressed,
      inputBytes,
      proof.c,
      proof.s_1,
      preoutUncompressed
    );
    
    // 6. Verify the result
    expect(result.ok).to.be.true;
    expect(result.out).to.not.equal(ethers.ZeroHash);
    
    console.log('On-chain verification result:');
    console.log('  ok:', result.ok);
    console.log('  out:', result.out);
    
    // 7. Verify that the output matches what we expect from JavaScript
    // The output should be keccak256(preout || input)
    const expectedOutput = ethers.keccak256(
      ethers.concat([preoutUncompressed, inputBytes])
    );
    
    expect(result.out).to.equal(expectedOutput);
    console.log('Expected output:', expectedOutput);
  });

  it('should reject invalid proof', async () => {
    // Generate a valid proof first
    const { sk, pk } = generateKeyPair();
    const input = 'test message';
    const inputBytes = new TextEncoder().encode(input);
    const proof = prove(sk, pk, input);
    
    // Convert to uncompressed format (128 bytes)
    const pkBytes = pk.toRawBytes(false);
    const pkUncompressed = new Uint8Array(128);
    pkUncompressed.set(pkBytes.slice(0, 48), 16);
    pkUncompressed.set(pkBytes.slice(48, 96), 80);
    
    const preoutPoint = bls12_381.G1.ProjectivePoint.fromHex(bytesToHex(proof.preout));
    const preoutBytes = preoutPoint.toRawBytes(false);
    const preoutUncompressed = new Uint8Array(128);
    preoutUncompressed.set(preoutBytes.slice(0, 48), 16);
    preoutUncompressed.set(preoutBytes.slice(48, 96), 80);
    
    // Tamper with the proof by changing the challenge
    const tamperedC = proof.c + 1n;
    
    // Call the on-chain verifier with tampered proof
    const result = await verifier.verify(
      pkUncompressed,
      inputBytes,
      tamperedC,
      proof.s_1,
      preoutUncompressed
    );
    
    // Should fail verification
    expect(result.ok).to.be.false;
    expect(result.out).to.equal(ethers.ZeroHash);
  });

  it('should handle different input types', async () => {
    const { sk, pk } = generateKeyPair();
    
    // Test with byte array input
    const inputBytes = new Uint8Array([1, 2, 3, 4, 5, 6, 7, 8]);
    const proof = prove(sk, pk, inputBytes);
    
    // Convert to uncompressed format (128 bytes)
    const pkBytes = pk.toRawBytes(false);
    const pkUncompressed = new Uint8Array(128);
    pkUncompressed.set(pkBytes.slice(0, 48), 16);
    pkUncompressed.set(pkBytes.slice(48, 96), 80);
    
    const preoutPoint = bls12_381.G1.ProjectivePoint.fromHex(bytesToHex(proof.preout));
    const preoutBytes = preoutPoint.toRawBytes(false);
    const preoutUncompressed = new Uint8Array(128);
    preoutUncompressed.set(preoutBytes.slice(0, 48), 16);
    preoutUncompressed.set(preoutBytes.slice(48, 96), 80);
    
    // Call the on-chain verifier
    const result = await verifier.verify(
      pkUncompressed,
      inputBytes,
      proof.c,
      proof.s_1,
      preoutUncompressed
    );
    
    // Should succeed
    expect(result.ok).to.be.true;
    expect(result.out).to.not.equal(ethers.ZeroHash);
    
    // Verify expected output
    const expectedOutput = ethers.keccak256(
      ethers.concat([preoutUncompressed, inputBytes])
    );
    expect(result.out).to.equal(expectedOutput);
  });
});
